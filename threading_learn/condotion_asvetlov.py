from threading import Condition, RLock, Thread
import time


class Queue(object):
    """Рассмотрим очередь на фиксированное количество элементов.
    Когда очередь пуста - поток, желающий получить новый элемент должен ждать.
    Аналогично с переполненной очередью."""
    def __init__(self, size=5):
        self._size = size
        self._queue = []

        '''Обратите внимание - блокиратор один на обе условные переменные. 
        Это важно. _full и _empty взаимозависимы.
        Хотя threading.Condition позволяет не указывать блокиратор, 
         создавая новый RLock автоматически - не поступайте так.
        Можно поймать race condition.Гораздо надежней и наглядней делать все явно. 
        В нашем случае race condition был бы в явном виде - пусть и скрытый из за GIL.
        '''
        self._mutex = RLock()
        self._empty = Condition(self._mutex)
        self._full = Condition(self._mutex)

    def put(self, val):
        with self._full:  # Входим в блокиратор

            '''Проверка условия всегда выполняется в блокировке. 
            Никто другой в это же время условие поменять не сможет'''
            while len(self._queue) >= self._size:

                '''Этот метод освободит блокировку (отдав управление ОС) 
                   и будет ждать извещения .notify.
                После получения сигнала выполнение продолжится при снова взятой блокировке.'''
                self._full.wait()  

            self._queue.append(val)
            self._empty.notify()
            print('put ', val)

    def get(self):
        with self._empty:  # Входим в блокиратор

            '''Проверка условия всегда выполняется в блокировке. 
            Никто другой в это же время условие поменять не сможет'''
            while len(self._queue) == 0:

                '''Этот метод освободит блокировку (отдав управление ОС) 
                   и будет ждать извещения .notify.
                После получения сигнала выполнение продолжится при снова взятой блокировке.'''
                self._empty.wait()

            '''Итак очередь не пуста, как минимум один элемент в ней есть.
            Может быть и больше - нас сейчас это не волнует.Блокировка все еще есть.'''
            
            ret = self._queue.pop(0)  # Получаем элемент из очереди
            self._full.notify()       # Извещаем что в очереди появилось свободное место
            
            '''Возвращаем полученное. 
            Выходя из with освобождаем блокировку - другие потоки могут работать с очередью дальше'''
            return ret

'''Итак, условные переменные - 
это способ синхронизировать доступ к объектам при помощи блокировки 
и при этом возможность послать сигнал ожидающим потокам.'''

q = Queue(5)


def getter(end):
    while True:
        time.sleep(2)
        r = q.get()
        print('pop ', r)
        if r == end-1:
            break


def setter(n):
    for i in range(1, n):
        time.sleep(1)
        q.put(i)

Thread(target=getter, args=(10,)).start()
Thread(target=setter, args=(10,)).start()

